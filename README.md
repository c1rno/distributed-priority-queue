# Distributed priority queue

Точка отсчета [Skeap & Seap: Scalable Distributed Priority Queues for Constantand Arbitrary Priorities](https://arxiv.org/pdf/1805.03472.pdf)
Тут еще немного инфы про роутинг [A Self-Stabilizing General De Bruijn Graph](https://arxiv.org/pdf/1708.06542.pdf)

## Базовые сущности, которые необходимы для mvp

### Aggregation Tree

Распределенная структура данных (описана в _аппендиксе А_ статьи), ориентированный граф.
 Граф строится из _нод_ (это отдельный процесс/сервер/т.д.), _нода_ в свою очередь состоит
 из трех _виртуальных нод_ - _левая_, _средняя_, _правая_, данные хранятся в них


_Ноды_ имеют свой уникальный идентификатор - _id_ - какой он будет нужно придумать;
 _виртуальные ноды_ идентифицируются по _лейблу_, _лейбл средней виртуальной ноды_
 вычисляется как хеш от _id ноды_, _лейбл левой виртуальной ноды_ = _лейбл средней виртуальной ноды_ / 2,
 _лейбл правой виртуальной ноды_ = ( _лейбл средней виртуальной ноды_ + 1 ) / 2.


Более того, _id нод_ дожны быть "сравнимы"/"comparable", т.е. для них должны быть определены операции больше/меньше/равно.
 Это нужно для роутинга - ноды должны знать свих "чилдов" и "парентов", которые определяются
 при сравнении _id нод_; _id_ одной больше другой - первая парент и наоборот. И еще, про _id нод_, их
 зацикливают `pred(v_min) =v_max and succ(v_max) =v_min`, итого, _физические ноды_ просто последовательно
 выстраиваются в кольцо.


Помимо _id_ "чилда" и "парента" каждая _нода_ должна знать _лейблы_ своих _виртуальных нод_, а так же
 лейблы _виртуальных нод_ своих "чилда" и "парента".






